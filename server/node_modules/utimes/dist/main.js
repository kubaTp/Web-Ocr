"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lutimesSync = exports.lutimes = exports.utimesSync = exports.utimes = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/**
 * The native addon binding.
 */
const nativeAddon = (function () {
    const gyp = require('@mapbox/node-pre-gyp');
    const packagePath = path_1.default.resolve(path_1.default.join(__dirname, '../package.json'));
    const addonPath = gyp.find(packagePath);
    if (!fs_1.default.existsSync(addonPath)) {
        throw new Error('Could not find the "utimes.node" file. See: https://github.com/baileyherbert/utimes/issues/12');
    }
    return require(addonPath);
})();
/**
 * Whether or not the current platform supports the native addon.
 */
const useNativeAddon = ['darwin', 'win32', 'linux'].indexOf(process.platform) >= 0;
function utimes(path, options, callback) {
    return invokeWrapped(path, options, true, callback);
}
exports.utimes = utimes;
/**
 * Synchronously updates the timestamps on the given path(s).
 *
 * @param path
 * @param options
 */
function utimesSync(path, options) {
    return invokeUTimesSync(path, options, true);
}
exports.utimesSync = utimesSync;
function lutimes(path, options, callback) {
    return invokeWrapped(path, options, false, callback);
}
exports.lutimes = lutimes;
/**
 * Synchronously updates the timestamps on the given path(s).
 *
 * @param path
 * @param options
 */
function lutimesSync(path, options) {
    return invokeUTimesSync(path, options, false);
}
exports.lutimesSync = lutimesSync;
/**
 * Invokes utimes with the given options, and implements callbacks/promises based on the parameters.
 *
 * @param path
 * @param options
 * @param resolveLinks
 * @param callback
 * @returns
 */
function invokeWrapped(path, options, resolveLinks, callback) {
    if (typeof callback === 'function') {
        return invokeUTimes(path, options, resolveLinks, callback);
    }
    else {
        return new Promise((resolve, reject) => {
            invokeUTimes(path, options, resolveLinks, error => {
                if (typeof error !== 'undefined') {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
}
/**
 * Invokes utimes with the given options.
 *
 * @param path A string path or an array of string paths.
 * @param options The timestamps to use.
 * @param resolveLinks Whether or not to resolve symbolic links and update their target file instead.
 * @param callback Function to invoke when completed.
 * @returns
 */
function invokeUTimes(path, options, resolveLinks, callback) {
    const targets = getNormalizedPaths(path);
    const times = getNormalizedOptions(options);
    const flags = getFlags(times);
    const invokeAtIndex = (index) => {
        const target = targets[index];
        if (target === undefined) {
            return callback();
        }
        // Invoke the native addon on supported platforms
        if (useNativeAddon) {
            invokeBindingAsync(target, times, flags, resolveLinks, error => error !== undefined ? callback(error) : invokeAtIndex(index + 1));
        }
        // Fall back to using `fs.utimes` for other platforms
        else {
            fs_1.default[resolveLinks ? 'stat' : 'lstat'](target, (statsErr, stats) => {
                if (statsErr)
                    return callback(statsErr);
                fs_1.default[resolveLinks ? 'utimes' : 'lutimes'](target, (flags & 4 ? times.atime : stats.atime.getTime()) / 1000, (flags & 2 ? times.mtime : stats.mtime.getTime()) / 1000, error => error ? callback(error) : invokeAtIndex(index + 1));
            });
        }
    };
    // Return if there's nothing to do
    if (!flags || !targets.length) {
        return callback();
    }
    // Start setting timestamps
    invokeAtIndex(0);
}
/**
 * Invokes utimes synchronously with the given options.
 *
 * @param path A string path or an array of string paths.
 * @param options The timestamps to use.
 * @param resolveLinks Whether or not to resolve symbolic links and update their target file instead.
 * @returns
 */
function invokeUTimesSync(path, options, resolveLinks) {
    const targets = getNormalizedPaths(path);
    const times = getNormalizedOptions(options);
    const flags = getFlags(times);
    const invokeAtIndex = (index) => {
        const target = targets[index];
        if (target === undefined) {
            return;
        }
        // Invoke the native addon on supported platforms
        if (useNativeAddon) {
            invokeBindingSync(target, times, flags, resolveLinks);
            invokeAtIndex(index + 1);
        }
        // Fall back to using `fs.utimes` for other platforms
        else {
            const stats = fs_1.default[resolveLinks ? 'statSync' : 'lstatSync'](target);
            fs_1.default[resolveLinks ? 'utimesSync' : 'lutimesSync'](target, (flags & 4 ? times.atime : stats.atime.getTime()) / 1000, (flags & 2 ? times.mtime : stats.mtime.getTime()) / 1000);
            invokeAtIndex(index + 1);
        }
    };
    // Return if there's nothing to do
    if (!flags || !targets.length) {
        return;
    }
    // Start setting timestamps
    invokeAtIndex(0);
}
/**
 * Converts the given string or string array into a guaranteed array of strings.
 *
 * @param paths
 */
function getNormalizedPaths(paths) {
    if (typeof paths === 'string') {
        assertPath('path', paths);
        return [paths];
    }
    if (Array.isArray(paths)) {
        for (let i = 0; i < paths.length; i++) {
            const path = paths[i];
            assertPath(`paths[${i}]`, path);
        }
        return paths;
    }
    throw new Error('Path must be a string or array');
}
/**
 * Replaces missing options with zero values.
 *
 * @param options
 */
function getNormalizedOptions(options) {
    if (typeof options === 'number') {
        options = {
            btime: options,
            mtime: options,
            atime: options
        };
    }
    if (typeof options === 'undefined' || options === null) {
        options = {
            btime: 0,
            mtime: 0,
            atime: 0
        };
    }
    if (typeof options !== 'object') {
        throw new Error('Options must be an object');
    }
    assertTimestamp('btime', options.btime);
    assertTimestamp('mtime', options.mtime);
    assertTimestamp('atime', options.atime);
    return {
        btime: options.btime || 0,
        mtime: options.mtime || 0,
        atime: options.atime || 0
    };
}
/**
 * Calculates the flags to send to the binding.
 *
 * @param options
 */
function getFlags(options) {
    let flags = 0;
    if (options.btime)
        flags |= 1;
    if (options.mtime)
        flags |= 2;
    if (options.atime)
        flags |= 4;
    return flags;
}
/**
 * Calls the binding and invokes a callback function.
 *
 * @param path
 * @param times
 * @param flags
 */
function invokeBindingAsync(path, times, flags, resolveLinks, callback) {
    nativeAddon.utimes(getPathBuffer(path), flags, times.btime, times.mtime, times.atime, resolveLinks, (result) => {
        if (typeof result !== 'undefined') {
            const name = resolveLinks ? 'utimes' : 'lutimes';
            const message = result.message.trim().replace(/\.$/, '');
            callback(new Error(`${message}, ${name} '${path}'`));
            return;
        }
        callback();
    });
}
/**
 * Calls the binding synchronously.
 *
 * @param path
 * @param times
 * @param flags
 */
function invokeBindingSync(path, times, flags, resolveLinks) {
    try {
        nativeAddon.utimesSync(getPathBuffer(path), flags, times.btime, times.mtime, times.atime, resolveLinks);
    }
    catch (error) {
        const name = resolveLinks ? 'utimes' : 'lutimes';
        const message = error.message.trim().replace(/\.$/, '');
        throw new Error(`${message}, ${name} '${path}'`);
    }
}
/**
 * Converts a path string into a buffer.
 *
 * @param target
 * @returns
 */
function getPathBuffer(target) {
    const targetLong = path_1.default._makeLong(target);
    const buffer = Buffer.alloc(Buffer.byteLength(targetLong, 'utf-8') + 1);
    buffer.write(targetLong, 0, buffer.length - 1, 'utf-8');
    buffer[buffer.length - 1] = 0;
    if (buffer.indexOf(0) !== buffer.length - 1) {
        throw new Error('Path must be a string without null bytes');
    }
    return buffer;
}
/**
 * @param key
 * @param value
 */
function assertPath(key, value) {
    if (typeof value !== 'string') {
        throw new Error(key + ' must be a string');
    }
    if (value.length === 0) {
        throw new Error(key + ' must not be empty');
    }
    if (value.indexOf('\u0000') !== -1) {
        throw new Error(key + ' must be a string without null bytes');
    }
}
function assertTimestamp(key, value) {
    if (value === undefined) {
        return;
    }
    if (typeof value !== 'number') {
        throw new Error(key + ' must be a number or undefined');
    }
    if (Math.floor(value) !== value) {
        throw new Error(key + ' must be an integer');
    }
    if (value < 0) {
        throw new Error(key + ' must be a positive integer');
    }
    if (value > Math.pow(2, 48) - 1) {
        throw new Error(key + ' must not be more than ' + (Math.pow(2, 48) - 1));
    }
}
//# sourceMappingURL=main.js.map